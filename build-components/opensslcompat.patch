diff --git a/neutron-qt.pro b/neutron-qt.pro
index 6d15d5a..96b55fb 100755
--- a/neutron-qt.pro
+++ b/neutron-qt.pro
@@ -172,6 +172,7 @@ windows:QMAKE_CXXFLAGS_WARN_ON += -Wno-cpp -Wno-maybe-uninitialized
 DEPENDPATH += src src/json src/qt
 
 HEADERS += src/activemasternode.h \
+    src/opensslcompat.h \
     src/addrdb.h \
     src/addrman.h \
     src/alert.h \
@@ -280,6 +281,7 @@ HEADERS += src/activemasternode.h \
     src/script/standard.h
 
 SOURCES += src/activemasternode.cpp \
+    src/opensslcompat.c \
     src/addrdb.cpp \
     src/addrman.cpp \
     src/alert.cpp \
diff --git a/src/base58.h b/src/base58.h
index 1cebafb..2ed6623 100644
--- a/src/base58.h
+++ b/src/base58.h
@@ -22,6 +22,7 @@
 #include "key.h"
 #include "script.h"
 #include "script/standard.h"
+#include "opensslcompat.h"
 
 static const char* pszBase58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
 // Encode a byte sequence as a base58-encoded string
@@ -49,7 +50,7 @@ inline std::string EncodeBase58(const unsigned char* pbegin, const unsigned char
     CBigNum rem;
     while (bn > bn0)
     {
-        if (!BN_div(&dv, &rem, &bn, &bn58, pctx))
+        if (!BN_div(dv.getBN(), rem.getBN(), bn.getBN(), bn58.getBN(), pctx))
             throw bignum_error("EncodeBase58 : BN_div failed");
         bn = dv;
         unsigned int c = rem.getulong();
@@ -96,7 +97,7 @@ inline bool DecodeBase58(const char* psz, std::vector<unsigned char>& vchRet)
             break;
         }
         bnChar.setulong(p1 - pszBase58);
-        if (!BN_mul(&bn, &bn, &bn58, pctx))
+        if (!BN_mul(bn.getBN(), bn.getBN(), bn58.getBN(), pctx))
             throw bignum_error("DecodeBase58 : BN_mul failed");
         bn += bnChar;
     }
diff --git a/src/bignum.h b/src/bignum.h
index 2352e7b..4fbf793 100644
--- a/src/bignum.h
+++ b/src/bignum.h
@@ -1,31 +1,29 @@
 // Copyright (c) 2009-2010 Satoshi Nakamoto
 // Copyright (c) 2009-2012 The Bitcoin developers
+// Copyright (c) 2017-2019 The Swipp developers
+// Copyright (c) 2019 The Neutron developers
 // Distributed under the MIT/X11 software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+// file COPYING.daemon or http://www.opensource.org/licenses/mit-license.php.
 
-#ifndef BITCOIN_BIGNUM_H
-#define BITCOIN_BIGNUM_H
-
-#include "serialize.h"
-#include "uint256.h"
-#include "version.h"
+#ifndef __BIGNUM_H__
+#define __BIGNUM_H__
 
 #include <openssl/bn.h>
-
+#include <openssl/opensslv.h>
 #include <stdexcept>
 #include <vector>
-
 #include <stdint.h>
 
-/** Errors thrown by the bignum class */
+#include "serialize.h"
+#include "uint256.h"
+#include "version.h"
+
 class bignum_error : public std::runtime_error
 {
 public:
-    explicit bignum_error(const std::string& str) : std::runtime_error(str) {}
+    explicit bignum_error(const std::string& str) : std::runtime_error(str) { }
 };
 
-
-/** RAII encapsulated BN_CTX (OpenSSL bignum context) */
 class CAutoBN_CTX
 {
 protected:
@@ -36,6 +34,7 @@ public:
     CAutoBN_CTX()
     {
         pctx = BN_CTX_new();
+
         if (pctx == NULL)
             throw bignum_error("CAutoBN_CTX : BN_CTX_new() returned NULL");
     }
@@ -46,120 +45,136 @@ public:
             BN_CTX_free(pctx);
     }
 
-    operator BN_CTX*() { return pctx; }
-    BN_CTX& operator*() { return *pctx; }
+    operator BN_CTX*()   { return pctx; }
+    BN_CTX& operator*()  { return *pctx; }
     BN_CTX** operator&() { return &pctx; }
-    bool operator!() { return (pctx == NULL); }
+    bool operator!()     { return pctx == NULL; }
 };
 
-
-/** C++ wrapper for BIGNUM (OpenSSL bignum) */
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 class CBigNum : public BIGNUM
+#else
+class CBigNum
+#endif
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+private:
+    BIGNUM *bn;
+#endif
+
 public:
     CBigNum()
     {
+        #if OPENSSL_VERSION_NUMBER < 0x10100000L
         BN_init(this);
+        #else
+        bn = BN_new();
+        #endif
     }
 
-    CBigNum(const CBigNum& b)
+    CBigNum(const CBigNum& b) : CBigNum()
     {
-        BN_init(this);
-        if (!BN_copy(this, &b))
+        if (!BN_copy(getBN(), b.getBNConst()))
         {
-            BN_clear_free(this);
+            BN_clear_free(getBN());
             throw bignum_error("CBigNum::CBigNum(const CBigNum&) : BN_copy failed");
         }
     }
 
     CBigNum& operator=(const CBigNum& b)
     {
-        if (!BN_copy(this, &b))
+        if (!BN_copy(getBN(), b.getBNConst()))
             throw bignum_error("CBigNum::operator= : BN_copy failed");
-        return (*this);
+
+        return *this;
     }
 
     ~CBigNum()
     {
-        BN_clear_free(this);
+        BN_clear_free(getBN());
     }
 
-    //CBigNum(char n) is not portable.  Use 'signed char' or 'unsigned char'.
-    CBigNum(signed char n)        { BN_init(this); if (n >= 0) setulong(n); else setint64(n); }
-    CBigNum(short n)              { BN_init(this); if (n >= 0) setulong(n); else setint64(n); }
-    CBigNum(int n)                { BN_init(this); if (n >= 0) setulong(n); else setint64(n); }
-    CBigNum(long n)               { BN_init(this); if (n >= 0) setulong(n); else setint64(n); }
-    CBigNum(long long n)          { BN_init(this); setint64(n); }
-    CBigNum(unsigned char n)      { BN_init(this); setulong(n); }
-    CBigNum(unsigned short n)     { BN_init(this); setulong(n); }
-    CBigNum(unsigned int n)       { BN_init(this); setulong(n); }
-    CBigNum(unsigned long n)      { BN_init(this); setulong(n); }
-    CBigNum(unsigned long long n) { BN_init(this); setuint64(n); }
-    explicit CBigNum(uint256 n)   { BN_init(this); setuint256(n); }
+    CBigNum(signed char n) : CBigNum()        { if (n >= 0) setulong(n); else setint64(n); }
+    CBigNum(short n) : CBigNum()              { if (n >= 0) setulong(n); else setint64(n); }
+    CBigNum(int n) : CBigNum()                { if (n >= 0) setulong(n); else setint64(n); }
+    CBigNum(long n) : CBigNum()               { if (n >= 0) setulong(n); else setint64(n); }
+    CBigNum(long long n) : CBigNum()          { setint64(n); }
+    CBigNum(unsigned char n) : CBigNum()      { setulong(n); }
+    CBigNum(unsigned short n) : CBigNum()     { setulong(n); }
+    CBigNum(unsigned int n) : CBigNum()       { setulong(n); }
+    CBigNum(unsigned long n) : CBigNum()      { setulong(n); }
+    CBigNum(unsigned long long n) : CBigNum() { setuint64(n); }
 
-    explicit CBigNum(const std::vector<unsigned char>& vch)
+    explicit CBigNum(uint256 n) : CBigNum()
+    {
+        setuint256(n);
+    }
+
+    explicit CBigNum(const std::vector<unsigned char>& vch) : CBigNum()
     {
-        BN_init(this);
         setvch(vch);
     }
 
-    /** Generates a cryptographically secure random number between zero and range exclusive
-    * i.e. 0 < returned number < range
-    * @param range The upper bound on the number.
-    * @return
-    */
-    static CBigNum  randBignum(const CBigNum& range) {
+    #if OPENSSL_VERSION_NUMBER < 0x10100000L
+    BIGNUM *getBN() { return this; }
+    const BIGNUM *getBNConst() const { return this; }
+    #else
+    BIGNUM *getBN() { return bn; }
+    const BIGNUM *getBNConst() const { return bn; }
+    #endif
+
+    // Generates a cryptographically secure random number between zero and range exclusive
+    static CBigNum randBignum(const CBigNum& range)
+    {
         CBigNum ret;
-        if(!BN_rand_range(&ret, &range)){
+
+        if (!BN_rand_range(ret.getBN(), range.getBNConst()))
             throw bignum_error("CBigNum:rand element : BN_rand_range failed");
-        }
+
         return ret;
     }
 
-    /** Generates a cryptographically secure random k-bit number
-    * @param k The bit length of the number.
-    * @return
-    */
-    static CBigNum RandKBitBigum(const uint32_t k){
+    // Generates a cryptographically secure random k-bit number
+    static CBigNum RandKBitBigum(const uint32_t k)
+    {
         CBigNum ret;
-        if(!BN_rand(&ret, k, -1, 0)){
+
+        if (!BN_rand(ret.getBN(), k, -1, 0))
             throw bignum_error("CBigNum:rand element : BN_rand failed");
-        }
+
         return ret;
     }
 
-    /**Returns the size in bits of the underlying bignum.
-     *
-     * @return the size
-     */
-    int bitSize() const{
-        return  BN_num_bits(this);
+    int bitSize() const
+    {
+        return  BN_num_bits(getBNConst());
     }
 
-
     void setulong(unsigned long n)
     {
-        if (!BN_set_word(this, n))
+        if (!BN_set_word(getBN(), n))
             throw bignum_error("CBigNum conversion from unsigned long : BN_set_word failed");
     }
 
     unsigned long getulong() const
     {
-        return BN_get_word(this);
+        return BN_get_word(getBNConst());
     }
 
     unsigned int getuint() const
     {
-        return BN_get_word(this);
+        return BN_get_word(getBNConst());
     }
 
     int getint() const
     {
-        unsigned long n = BN_get_word(this);
-        if (!BN_is_negative(this))
-            return (n > (unsigned long)std::numeric_limits<int>::max() ? std::numeric_limits<int>::max() : n);
-        else
-            return (n > (unsigned long)std::numeric_limits<int>::max() ? std::numeric_limits<int>::min() : -(int)n);
+        unsigned long n = BN_get_word(getBNConst());
+
+        if (!BN_is_negative(getBNConst())) {
+            return (n > (unsigned long) std::numeric_limits<int>::max() ? std::numeric_limits<int>::max() : n);
+        } else {
+            return (n > (unsigned long) std::numeric_limits<int>::max() ? std::numeric_limits<int>::min() : -(int) n);
+        }
     }
 
     void setint64(int64_t sn)
@@ -169,54 +184,68 @@ public:
         bool fNegative;
         uint64_t n;
 
-        if (sn < (int64_t)0)
+        if (sn < (int64_t) 0)
         {
-            // Since the minimum signed integer cannot be represented as positive so long as its type is signed, and it's not well-defined what happens if you make it unsigned before negating it, we instead increment the negative integer by 1, convert it, then increment the (now positive) unsigned integer by 1 to compensate
             n = -(sn + 1);
             ++n;
             fNegative = true;
-        } else {
+        }
+        else
+        {
             n = sn;
             fNegative = false;
         }
 
         bool fLeadingZeroes = true;
+
         for (int i = 0; i < 8; i++)
         {
             unsigned char c = (n >> 56) & 0xff;
             n <<= 8;
+
             if (fLeadingZeroes)
             {
                 if (c == 0)
                     continue;
+
                 if (c & 0x80)
                     *p++ = (fNegative ? 0x80 : 0);
                 else if (fNegative)
                     c |= 0x80;
+
                 fLeadingZeroes = false;
             }
+
             *p++ = c;
         }
+
         unsigned int nSize = p - (pch + 4);
+
         pch[0] = (nSize >> 24) & 0xff;
         pch[1] = (nSize >> 16) & 0xff;
         pch[2] = (nSize >> 8) & 0xff;
         pch[3] = (nSize) & 0xff;
-        BN_mpi2bn(pch, p - pch, this);
+        BN_mpi2bn(pch, p - pch, getBN());
     }
 
     uint64_t getuint64()
     {
-        unsigned int nSize = BN_bn2mpi(this, NULL);
+        unsigned int nSize = BN_bn2mpi(getBN(), NULL);
+
         if (nSize < 4)
             return 0;
+
         std::vector<unsigned char> vch(nSize);
-        BN_bn2mpi(this, &vch[0]);
+        BN_bn2mpi(getBN(), &vch[0]);
+
         if (vch.size() > 4)
             vch[4] &= 0x7f;
+
         uint64_t n = 0;
+
         for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)
-            ((unsigned char*)&n)[i] = vch[j];
+            ((unsigned char*) &n)[i] = vch[j];
+
         return n;
     }
 
@@ -225,26 +254,33 @@ public:
         unsigned char pch[sizeof(n) + 6];
         unsigned char* p = pch + 4;
         bool fLeadingZeroes = true;
+
         for (int i = 0; i < 8; i++)
         {
             unsigned char c = (n >> 56) & 0xff;
             n <<= 8;
+
             if (fLeadingZeroes)
             {
                 if (c == 0)
                     continue;
+
                 if (c & 0x80)
                     *p++ = 0;
+
                 fLeadingZeroes = false;
             }
+
             *p++ = c;
         }
+
         unsigned int nSize = p - (pch + 4);
+
         pch[0] = (nSize >> 24) & 0xff;
         pch[1] = (nSize >> 16) & 0xff;
         pch[2] = (nSize >> 8) & 0xff;
         pch[3] = (nSize) & 0xff;
-        BN_mpi2bn(pch, p - pch, this);
+        BN_mpi2bn(pch, p - pch, getBN());
     }
 
     void setuint256(uint256 n)
@@ -252,69 +288,86 @@ public:
         unsigned char pch[sizeof(n) + 6];
         unsigned char* p = pch + 4;
         bool fLeadingZeroes = true;
-        unsigned char* pbegin = (unsigned char*)&n;
+        unsigned char* pbegin = (unsigned char*) &n;
         unsigned char* psrc = pbegin + sizeof(n);
+
         while (psrc != pbegin)
         {
             unsigned char c = *(--psrc);
+
             if (fLeadingZeroes)
             {
                 if (c == 0)
                     continue;
+
                 if (c & 0x80)
                     *p++ = 0;
+
                 fLeadingZeroes = false;
             }
+
             *p++ = c;
         }
+
         unsigned int nSize = p - (pch + 4);
+
         pch[0] = (nSize >> 24) & 0xff;
         pch[1] = (nSize >> 16) & 0xff;
         pch[2] = (nSize >> 8) & 0xff;
         pch[3] = (nSize >> 0) & 0xff;
-        BN_mpi2bn(pch, p - pch, this);
+        BN_mpi2bn(pch, p - pch, getBN());
     }
 
     uint256 getuint256() const
     {
-        unsigned int nSize = BN_bn2mpi(this, NULL);
+        unsigned int nSize = BN_bn2mpi(getBNConst(), NULL);
+
         if (nSize < 4)
             return 0;
+
         std::vector<unsigned char> vch(nSize);
-        BN_bn2mpi(this, &vch[0]);
+        BN_bn2mpi(getBNConst(), &vch[0]);
+
         if (vch.size() > 4)
             vch[4] &= 0x7f;
+
         uint256 n = 0;
-        for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)
-            ((unsigned char*)&n)[i] = vch[j];
+
+        for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--) {
+            ((unsigned char*) &n) [i] = vch[j];
+        }
+
         return n;
     }
 
-
     void setvch(const std::vector<unsigned char>& vch)
     {
         std::vector<unsigned char> vch2(vch.size() + 4);
         unsigned int nSize = vch.size();
-        // BIGNUM's byte stream format expects 4 bytes of
-        // big endian size data info at the front
+
         vch2[0] = (nSize >> 24) & 0xff;
         vch2[1] = (nSize >> 16) & 0xff;
         vch2[2] = (nSize >> 8) & 0xff;
         vch2[3] = (nSize >> 0) & 0xff;
-        // swap data to big endian
+
+        // Swap data to big endian
         reverse_copy(vch.begin(), vch.end(), vch2.begin() + 4);
-        BN_mpi2bn(&vch2[0], vch2.size(), this);
+        BN_mpi2bn(&vch2[0], vch2.size(), getBN());
     }
 
     std::vector<unsigned char> getvch() const
     {
-        unsigned int nSize = BN_bn2mpi(this, NULL);
+        unsigned int nSize = BN_bn2mpi(getBNConst(), NULL);
+
         if (nSize <= 4)
             return std::vector<unsigned char>();
+
         std::vector<unsigned char> vch(nSize);
-        BN_bn2mpi(this, &vch[0]);
+        BN_bn2mpi(getBNConst(), &vch[0]);
+
         vch.erase(vch.begin(), vch.begin() + 4);
         reverse(vch.begin(), vch.end());
+
         return vch;
     }
 
@@ -323,78 +376,107 @@ public:
         unsigned int nSize = nCompact >> 24;
         std::vector<unsigned char> vch(4 + nSize);
         vch[3] = nSize;
-        if (nSize >= 1) vch[4] = (nCompact >> 16) & 0xff;
-        if (nSize >= 2) vch[5] = (nCompact >> 8) & 0xff;
-        if (nSize >= 3) vch[6] = (nCompact >> 0) & 0xff;
-        BN_mpi2bn(&vch[0], vch.size(), this);
+
+        if (nSize >= 1)
+            vch[4] = (nCompact >> 16) & 0xff;
+        if (nSize >= 2)
+            vch[5] = (nCompact >> 8) & 0xff;
+        if (nSize >= 3)
+            vch[6] = (nCompact >> 0) & 0xff;
+
+        BN_mpi2bn(&vch[0], vch.size(), getBN());
         return *this;
     }
 
     unsigned int GetCompact() const
     {
-        unsigned int nSize = BN_bn2mpi(this, NULL);
+        unsigned int nSize = BN_bn2mpi(getBNConst(), NULL);
         std::vector<unsigned char> vch(nSize);
+
         nSize -= 4;
-        BN_bn2mpi(this, &vch[0]);
+        BN_bn2mpi(getBNConst(), &vch[0]);
         unsigned int nCompact = nSize << 24;
-        if (nSize >= 1) nCompact |= (vch[4] << 16);
-        if (nSize >= 2) nCompact |= (vch[5] << 8);
-        if (nSize >= 3) nCompact |= (vch[6] << 0);
+
+        if (nSize >= 1)
+            nCompact |= (vch[4] << 16);
+        if (nSize >= 2)
+            nCompact |= (vch[5] << 8);
+        if (nSize >= 3)
+            nCompact |= (vch[6] << 0);
+
         return nCompact;
     }
 
     void SetHex(const std::string& str)
     {
-        // skip 0x
         const char* psz = str.c_str();
-        while (isspace(*psz))
-            psz++;
         bool fNegative = false;
+
+        while (isspace(*psz)) {
+            psz++;
+        }
+
         if (*psz == '-')
         {
             fNegative = true;
             psz++;
         }
+
         if (psz[0] == '0' && tolower(psz[1]) == 'x')
             psz += 2;
+
         while (isspace(*psz))
             psz++;
 
-        // hex string to bignum
-        static const signed char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };
+        // Hex string to bignum
+        static const signed char phexdigit[256] =
+        {
+            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,
+            0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+            0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0
+        };
+
         *this = 0;
+
         while (isxdigit(*psz))
         {
             *this <<= 4;
-            int n = phexdigit[(unsigned char)*psz++];
+            int n = phexdigit[(unsigned char) *psz++];
             *this += n;
         }
+
         if (fNegative)
             *this = 0 - *this;
     }
 
-    std::string ToString(int nBase=10) const
+    std::string ToString(int nBase = 10) const
     {
         CAutoBN_CTX pctx;
         CBigNum bnBase = nBase;
         CBigNum bn0 = 0;
         std::string str;
         CBigNum bn = *this;
-        BN_set_negative(&bn, false);
+        BN_set_negative(bn.getBN(), false);
         CBigNum dv;
         CBigNum rem;
-        if (BN_cmp(&bn, &bn0) == 0)
+
+        if (BN_cmp(bn.getBN(), bn0.getBNConst()) == 0)
             return "0";
-        while (BN_cmp(&bn, &bn0) > 0)
+
+        while (BN_cmp(bn.getBN(), bn0.getBNConst()) > 0)
         {
-            if (!BN_div(&dv, &rem, &bn, &bnBase, pctx))
+            if (!BN_div(dv.getBN(), rem.getBN(), bn.getBNConst(), bnBase.getBNConst(), pctx))
                 throw bignum_error("CBigNum::ToString() : BN_div failed");
+
             bn = dv;
             unsigned int c = rem.getulong();
             str += "0123456789abcdef"[c];
         }
-        if (BN_is_negative(this))
+
+        if (BN_is_negative(getBNConst()))
             str += "-";
+
         reverse(str.begin(), str.end());
         return str;
     }
@@ -423,146 +505,142 @@ public:
         setvch(vch);
     }
 
-    /**
-    * exponentiation with an int. this^e
-    * @param e the exponent as an int
-    * @return
-    */
-    CBigNum pow(const int e) const {
+    CBigNum pow(const int e) const
+    {
         return this->pow(CBigNum(e));
     }
 
-    /**
-     * exponentiation this^e
-     * @param e the exponent
-     * @return
-     */
-    CBigNum pow(const CBigNum& e) const {
+    CBigNum pow(const CBigNum& e) const
+    {
         CAutoBN_CTX pctx;
         CBigNum ret;
-        if (!BN_exp(&ret, this, &e, pctx))
+
+        if (!BN_exp(ret.getBN(), getBNConst(), e.getBNConst(), pctx)) {
             throw bignum_error("CBigNum::pow : BN_exp failed");
+        }
+
         return ret;
     }
 
-    /**
-     * modular multiplication: (this * b) mod m
-     * @param b operand
-     * @param m modulus
-     */
-    CBigNum mul_mod(const CBigNum& b, const CBigNum& m) const {
+     // Modular multiplication: (BIGNUM_REF * b) mod m
+    CBigNum mul_mod(const CBigNum& b, const CBigNum& m) const
+    {
         CAutoBN_CTX pctx;
         CBigNum ret;
-        if (!BN_mod_mul(&ret, this, &b, &m, pctx))
+
+        if (!BN_mod_mul(ret.getBN(), getBNConst(), b.getBNConst(), m.getBNConst(), pctx)) {
             throw bignum_error("CBigNum::mul_mod : BN_mod_mul failed");
-        
+        }
+
         return ret;
     }
 
-    /**
-     * modular exponentiation: this^e mod n
-     * @param e exponent
-     * @param m modulus
-     */
-    CBigNum pow_mod(const CBigNum& e, const CBigNum& m) const {
+    // Modular exponentiation: BIGNUM_REF^e mod n
+    CBigNum pow_mod(const CBigNum& e, const CBigNum& m) const
+    {
         CAutoBN_CTX pctx;
         CBigNum ret;
-        if( e < 0){
+
+        if( e < 0) {
             // g^-x = (g^-1)^x
             CBigNum inv = this->inverse(m);
             CBigNum posE = e * -1;
-            if (!BN_mod_exp(&ret, &inv, &posE, &m, pctx))
+
+            if (!BN_mod_exp(ret.getBN(), inv.getBNConst(), posE.getBNConst(), m.getBNConst(), pctx)) {
                 throw bignum_error("CBigNum::pow_mod: BN_mod_exp failed on negative exponent");
-        }else
-            if (!BN_mod_exp(&ret, this, &e, &m, pctx))
-                throw bignum_error("CBigNum::pow_mod : BN_mod_exp failed");
+            }
+        } else if (!BN_mod_exp(ret.getBN(), getBNConst(), e.getBNConst(), m.getBNConst(), pctx)) {
+            throw bignum_error("CBigNum::pow_mod : BN_mod_exp failed");
+        }
 
         return ret;
     }
 
-    /**
-    * Calculates the inverse of this element mod m.
-    * i.e. i such this*i = 1 mod m
-    * @param m the modu
-    * @return the inverse
-    */
-    CBigNum inverse(const CBigNum& m) const {
+    CBigNum inverse(const CBigNum& m) const
+    {
         CAutoBN_CTX pctx;
         CBigNum ret;
-        if (!BN_mod_inverse(&ret, this, &m, pctx))
+
+        if (!BN_mod_inverse(ret.getBN(), getBNConst(), m.getBNConst(), pctx)) {
             throw bignum_error("CBigNum::inverse*= :BN_mod_inverse");
+        }
+
         return ret;
     }
 
-    /**
-     * Generates a random (safe) prime of numBits bits
-     * @param numBits the number of bits
-     * @param safe true for a safe prime
-     * @return the prime
-     */
-    static CBigNum generatePrime(const unsigned int numBits, bool safe = false) {
+    // Generates a random (safe) prime of numBits bits
+    static CBigNum generatePrime(const unsigned int numBits, bool safe = false)
+    {
         CBigNum ret;
-        if(!BN_generate_prime_ex(&ret, numBits, (safe == true), NULL, NULL, NULL))
+
+        if(!BN_generate_prime_ex(ret.getBN(), numBits, (safe == true), NULL, NULL, NULL))
             throw bignum_error("CBigNum::generatePrime*= :BN_generate_prime_ex");
+
         return ret;
     }
 
-    /**
-     * Calculates the greatest common divisor (GCD) of two numbers.
-     * @param m the second element
-     * @return the GCD
-     */
-    CBigNum gcd( const CBigNum& b) const{
+     // Calculates the greatest common divisor (GCD) of two numbers.
+    CBigNum gcd( const CBigNum& b) const
+    {
         CAutoBN_CTX pctx;
         CBigNum ret;
-        if (!BN_gcd(&ret, this, &b, pctx))
+
+        if (!BN_gcd(ret.getBN(), getBNConst(), b.getBNConst(), pctx))
             throw bignum_error("CBigNum::gcd*= :BN_gcd");
+
         return ret;
     }
 
-    /**
-    * Miller-Rabin primality test on this element
-    * @param checks: optional, the number of Miller-Rabin tests to run
-    * default causes error rate of 2^-80.
-    * @return true if prime
-    */
-    bool isPrime(const int checks=BN_prime_checks) const {
+    // Miller-Rabin primality test on BIGNUM_REF element
+    bool isPrime(const int checks = BN_prime_checks) const
+    {
         CAutoBN_CTX pctx;
-        int ret = BN_is_prime(this, checks, NULL, pctx, NULL);
-        if(ret < 0){
+
+        #if OPENSSL_VERSION_NUMBER < 0x10100000L
+        int ret = BN_is_prime(getBNConst(), checks, NULL, pctx, NULL);
+        #else
+        int ret = BN_is_prime_ex(getBNConst(), checks, pctx, NULL);
+        #endif
+
+        if(ret < 0)
             throw bignum_error("CBigNum::isPrime :BN_is_prime");
-        }
+
         return ret;
     }
 
-    bool isOne() const {
-        return BN_is_one(this);
+    bool isOne() const
+    {
+        return BN_is_one(getBNConst());
     }
 
-
     bool operator!() const
     {
-        return BN_is_zero(this);
+        return BN_is_zero(getBNConst());
     }
 
     CBigNum& operator+=(const CBigNum& b)
     {
-        if (!BN_add(this, this, &b))
+        if (!BN_add(getBN(), getBNConst(), b.getBNConst()))
             throw bignum_error("CBigNum::operator+= : BN_add failed");
+
         return *this;
     }
 
     CBigNum& operator-=(const CBigNum& b)
     {
-        *this = *this - b;
+        if (!BN_sub(getBN(), getBNConst(), b.getBNConst()))
+            throw bignum_error("CBigNum::operator+= : BN_add failed");
+
         return *this;
     }
 
     CBigNum& operator*=(const CBigNum& b)
     {
         CAutoBN_CTX pctx;
-        if (!BN_mul(this, this, &b, pctx))
+
+        if (!BN_mul(getBN(), getBNConst(), b.getBNConst(), pctx))
             throw bignum_error("CBigNum::operator*= : BN_mul failed");
+
         return *this;
     }
 
@@ -580,40 +658,42 @@ public:
 
     CBigNum& operator<<=(unsigned int shift)
     {
-        if (!BN_lshift(this, this, shift))
+        if (!BN_lshift(getBN(), getBNConst(), shift))
             throw bignum_error("CBigNum:operator<<= : BN_lshift failed");
+
         return *this;
     }
 
     CBigNum& operator>>=(unsigned int shift)
     {
-        // Note: BN_rshift segfaults on 64-bit if 2^shift is greater than the number
-        //   if built on ubuntu 9.04 or 9.10, probably depends on version of OpenSSL
+        // NOTE: BN_rshift segfaults on 64-bit if 2^shift is greater than the number
+        // if built on Ubuntu 9.04 or 9.10, probably depends on version of OpenSSL
         CBigNum a = 1;
         a <<= shift;
-        if (BN_cmp(&a, this) > 0)
+
+        if (BN_cmp(a.getBNConst(), getBNConst()) > 0)
         {
             *this = 0;
             return *this;
         }
 
-        if (!BN_rshift(this, this, shift))
+        if (!BN_rshift(getBN(), getBNConst(), shift))
             throw bignum_error("CBigNum:operator>>= : BN_rshift failed");
+
         return *this;
     }
 
 
     CBigNum& operator++()
     {
-        // prefix operator
-        if (!BN_add(this, this, BN_value_one()))
+        if (!BN_add(getBN(), getBNConst(), BN_value_one()))
             throw bignum_error("CBigNum::operator++ : BN_add failed");
+
         return *this;
     }
 
     const CBigNum operator++(int)
     {
-        // postfix operator
         const CBigNum ret = *this;
         ++(*this);
         return ret;
@@ -621,23 +701,22 @@ public:
 
     CBigNum& operator--()
     {
-        // prefix operator
         CBigNum r;
-        if (!BN_sub(&r, this, BN_value_one()))
+
+        if (!BN_sub(r.getBN(), getBNConst(), BN_value_one()))
             throw bignum_error("CBigNum::operator-- : BN_sub failed");
+
         *this = r;
         return *this;
     }
 
     const CBigNum operator--(int)
     {
-        // postfix operator
         const CBigNum ret = *this;
         --(*this);
         return ret;
     }
 
-
     friend inline const CBigNum operator-(const CBigNum& a, const CBigNum& b);
     friend inline const CBigNum operator/(const CBigNum& a, const CBigNum& b);
     friend inline const CBigNum operator%(const CBigNum& a, const CBigNum& b);
@@ -645,28 +724,30 @@ public:
     friend inline bool operator<(const CBigNum& a, const CBigNum& b);
 };
 
-
-
 inline const CBigNum operator+(const CBigNum& a, const CBigNum& b)
 {
     CBigNum r;
-    if (!BN_add(&r, &a, &b))
+
+    if (!BN_add(r.getBN(), a.getBNConst(), b.getBNConst()))
         throw bignum_error("CBigNum::operator+ : BN_add failed");
+
     return r;
 }
 
 inline const CBigNum operator-(const CBigNum& a, const CBigNum& b)
 {
     CBigNum r;
-    if (!BN_sub(&r, &a, &b))
+
+    if (!BN_sub(r.getBN(), a.getBNConst(), b.getBNConst()))
         throw bignum_error("CBigNum::operator- : BN_sub failed");
+
     return r;
 }
 
 inline const CBigNum operator-(const CBigNum& a)
 {
     CBigNum r(a);
-    BN_set_negative(&r, !BN_is_negative(&r));
+    BN_set_negative(r.getBN(), !BN_is_negative(r.getBNConst()));
     return r;
 }
 
@@ -674,8 +755,10 @@ inline const CBigNum operator*(const CBigNum& a, const CBigNum& b)
 {
     CAutoBN_CTX pctx;
     CBigNum r;
-    if (!BN_mul(&r, &a, &b, pctx))
+
+    if (!BN_mul(r.getBN(), a.getBNConst(), b.getBNConst(), pctx))
         throw bignum_error("CBigNum::operator* : BN_mul failed");
+
     return r;
 }
 
@@ -683,8 +766,10 @@ inline const CBigNum operator/(const CBigNum& a, const CBigNum& b)
 {
     CAutoBN_CTX pctx;
     CBigNum r;
-    if (!BN_div(&r, NULL, &a, &b, pctx))
+
+    if (!BN_div(r.getBN(), NULL, a.getBNConst(), b.getBNConst(), pctx))
         throw bignum_error("CBigNum::operator/ : BN_div failed");
+
     return r;
 }
 
@@ -692,16 +777,20 @@ inline const CBigNum operator%(const CBigNum& a, const CBigNum& b)
 {
     CAutoBN_CTX pctx;
     CBigNum r;
-    if (!BN_nnmod(&r, &a, &b, pctx))
+
+    if (!BN_nnmod(r.getBN(), a.getBNConst(), b.getBNConst(), pctx))
         throw bignum_error("CBigNum::operator% : BN_div failed");
+
     return r;
 }
 
 inline const CBigNum operator<<(const CBigNum& a, unsigned int shift)
 {
     CBigNum r;
-    if (!BN_lshift(&r, &a, shift))
+
+    if (!BN_lshift(r.getBN(), a.getBNConst(), shift))
         throw bignum_error("CBigNum:operator<< : BN_lshift failed");
+
     return r;
 }
 
@@ -712,13 +801,12 @@ inline const CBigNum operator>>(const CBigNum& a, unsigned int shift)
     return r;
 }
 
-inline bool operator==(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) == 0); }
-inline bool operator!=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) != 0); }
-inline bool operator<=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) <= 0); }
-inline bool operator>=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) >= 0); }
-inline bool operator<(const CBigNum& a, const CBigNum& b)  { return (BN_cmp(&a, &b) < 0); }
-inline bool operator>(const CBigNum& a, const CBigNum& b)  { return (BN_cmp(&a, &b) > 0); }
-
+inline bool operator==(const CBigNum& a, const CBigNum& b) { return (BN_cmp(a.getBNConst(), b.getBNConst()) == 0); }
+inline bool operator!=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(a.getBNConst(), b.getBNConst()) != 0); }
+inline bool operator<=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(a.getBNConst(), b.getBNConst()) <= 0); }
+inline bool operator>=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(a.getBNConst(), b.getBNConst()) >= 0); }
+inline bool operator<(const CBigNum& a, const CBigNum& b)  { return (BN_cmp(a.getBNConst(), b.getBNConst()) < 0); }
+inline bool operator>(const CBigNum& a, const CBigNum& b)  { return (BN_cmp(a.getBNConst(), b.getBNConst()) > 0); }
 inline std::ostream& operator<<(std::ostream &strm, const CBigNum &b) { return strm << b.ToString(10); }
 
 typedef  CBigNum Bignum;
diff --git a/src/crypter.cpp b/src/crypter.cpp
index 3f5303b..cf36fa3 100644
--- a/src/crypter.cpp
+++ b/src/crypter.cpp
@@ -10,6 +10,7 @@
 #include <windows.h>
 #endif
 
+#include "opensslcompat.h"
 #include "init.h"
 #include "util.h"
 #include "crypter.h"
@@ -73,15 +74,16 @@ bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned
     int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;
     vchCiphertext = std::vector<unsigned char> (nCLen);
 
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
 
     bool fOk = true;
 
-    EVP_CIPHER_CTX_init(&ctx);
-    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);
-    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);
-    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_init(ctx);
+    if (fOk) fOk = EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);
+    if (fOk) fOk = EVP_EncryptUpdate(ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);
+    if (fOk) fOk = EVP_EncryptFinal_ex(ctx, (&vchCiphertext[0])+nCLen, &nFLen);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
 
     if (!fOk) return false;
 
@@ -100,15 +102,16 @@ bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingM
 
     vchPlaintext = CKeyingMaterial(nPLen);
 
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
 
     bool fOk = true;
 
-    EVP_CIPHER_CTX_init(&ctx);
-    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);
-    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);
-    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_init(ctx);
+    if (fOk) fOk = EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);
+    if (fOk) fOk = EVP_DecryptUpdate(ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);
+    if (fOk) fOk = EVP_DecryptFinal_ex(ctx, (&vchPlaintext[0])+nPLen, &nFLen);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
 
     if (!fOk) return false;
 
@@ -156,15 +159,16 @@ bool EncryptAES256(const SecureString& sKey, const SecureString& sPlaintext, con
     sCiphertext.resize(nCLen);
 
     // Perform the encryption
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
 
     bool fOk = true;
 
-    EVP_CIPHER_CTX_init(&ctx);
-    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, (const unsigned char*) &sKey[0], (const unsigned char*) &sIV[0]);
-    if (fOk) fOk = EVP_EncryptUpdate(&ctx, (unsigned char*) &sCiphertext[0], &nCLen, (const unsigned char*) &sPlaintext[0], nLen);
-    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (unsigned char*) (&sCiphertext[0])+nCLen, &nFLen);
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_init(ctx);
+    if (fOk) fOk = EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, (const unsigned char*) &sKey[0], (const unsigned char*) &sIV[0]);
+    if (fOk) fOk = EVP_EncryptUpdate(ctx, (unsigned char*) &sCiphertext[0], &nCLen, (const unsigned char*) &sPlaintext[0], nLen);
+    if (fOk) fOk = EVP_EncryptFinal_ex(ctx, (unsigned char*) (&sCiphertext[0])+nCLen, &nFLen);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
 
     if (!fOk) return false;
 
@@ -186,15 +190,16 @@ bool DecryptAES256(const SecureString& sKey, const std::string& sCiphertext, con
 
     sPlaintext.resize(nPLen);
 
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
 
     bool fOk = true;
 
-    EVP_CIPHER_CTX_init(&ctx);
-    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, (const unsigned char*) &sKey[0], (const unsigned char*) &sIV[0]);
-    if (fOk) fOk = EVP_DecryptUpdate(&ctx, (unsigned char *) &sPlaintext[0], &nPLen, (const unsigned char *) &sCiphertext[0], nLen);
-    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (unsigned char *) (&sPlaintext[0])+nPLen, &nFLen);
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_init(ctx);
+    if (fOk) fOk = EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, (const unsigned char*) &sKey[0], (const unsigned char*) &sIV[0]);
+    if (fOk) fOk = EVP_DecryptUpdate(ctx, (unsigned char *) &sPlaintext[0], &nPLen, (const unsigned char *) &sCiphertext[0], nLen);
+    if (fOk) fOk = EVP_DecryptFinal_ex(ctx, (unsigned char *) (&sPlaintext[0])+nPLen, &nFLen);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
 
     if (!fOk) return false;
 
diff --git a/src/key.cpp b/src/key.cpp
index dccd9a9..5ceaa49 100644
--- a/src/key.cpp
+++ b/src/key.cpp
@@ -9,6 +9,7 @@
 
 #include "hash.h"
 #include "key.h"
+#include "opensslcompat.h"
 
 // Generate a private key from just the secret parameter
 int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)
@@ -79,7 +80,7 @@ int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned ch
     x = BN_CTX_get(ctx);
     if (!BN_copy(x, order)) { ret=-1; goto err; }
     if (!BN_mul_word(x, i)) { ret=-1; goto err; }
-    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }
+    if (!BN_add(x, x, ECDSA_SIG_getr(ecsig))) { ret=-1; goto err; }
     field = BN_CTX_get(ctx);
     if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }
     if (BN_cmp(x, field) >= 0) { ret=0; goto err; }
@@ -100,9 +101,9 @@ int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned ch
     if (!BN_zero(zero)) { ret=-1; goto err; }
     if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }
     rr = BN_CTX_get(ctx);
-    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }
+    if (!BN_mod_inverse(rr, ECDSA_SIG_getr(ecsig), order, ctx)) { ret=-1; goto err; }
     sor = BN_CTX_get(ctx);
-    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }
+    if (!BN_mod_mul(sor, ECDSA_SIG_gets(ecsig), rr, order, ctx)) { ret=-1; goto err; }
     eor = BN_CTX_get(ctx);
     if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }
     if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }
@@ -345,9 +346,9 @@ bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)
     BIGNUM *halforder = BN_CTX_get(ctx);
     EC_GROUP_get_order(group, order, ctx);
     BN_rshift1(halforder, order);
-    if (BN_cmp(sig->s, halforder) > 0) {
+    if (BN_cmp(ECDSA_SIG_gets(sig), halforder) > 0) {
         // enforce low S values, by negating the value (modulo the order) if above order/2.
-        BN_sub(sig->s, order, sig->s);
+        BN_sub(ECDSA_SIG_gets(sig), order, ECDSA_SIG_gets(sig));
     }
     BN_CTX_end(ctx);
     BN_CTX_free(ctx);
@@ -372,8 +373,8 @@ bool CKey::SignCompact(uint256 hash, std::vector<unsigned char>& vchSig)
         return false;
     vchSig.clear();
     vchSig.resize(65,0);
-    int nBitsR = BN_num_bits(sig->r);
-    int nBitsS = BN_num_bits(sig->s);
+    int nBitsR = BN_num_bits(ECDSA_SIG_getr(sig));
+    int nBitsS = BN_num_bits(ECDSA_SIG_gets(sig));
     if (nBitsR <= 256 && nBitsS <= 256)
     {
         int nRecId = -1;
@@ -398,8 +399,8 @@ bool CKey::SignCompact(uint256 hash, std::vector<unsigned char>& vchSig)
         }
 
         vchSig[0] = nRecId+27+(fCompressedPubKey ? 4 : 0);
-        BN_bn2bin(sig->r,&vchSig[33-(nBitsR+7)/8]);
-        BN_bn2bin(sig->s,&vchSig[65-(nBitsS+7)/8]);
+        BN_bn2bin(ECDSA_SIG_getr(sig),&vchSig[33-(nBitsR+7)/8]);
+        BN_bn2bin(ECDSA_SIG_gets(sig),&vchSig[65-(nBitsS+7)/8]);
         fOk = true;
     }
     ECDSA_SIG_free(sig);
@@ -418,8 +419,8 @@ bool CKey::SetCompactSignature(uint256 hash, const std::vector<unsigned char>& v
     if (nV<27 || nV>=35)
         return false;
     ECDSA_SIG *sig = ECDSA_SIG_new();
-    BN_bin2bn(&vchSig[1],32,sig->r);
-    BN_bin2bn(&vchSig[33],32,sig->s);
+    BN_bin2bn(&vchSig[1],32,ECDSA_SIG_getr(sig));
+    BN_bin2bn(&vchSig[33],32,ECDSA_SIG_gets(sig));
 
     EC_KEY_free(pkey);
     pkey = EC_KEY_new_by_curve_name(NID_secp256k1);
diff --git a/src/qt/rpcconsole.cpp b/src/qt/rpcconsole.cpp
index da9e5c5..dd11c86 100644
--- a/src/qt/rpcconsole.cpp
+++ b/src/qt/rpcconsole.cpp
@@ -14,6 +14,7 @@
 #include <db_cxx.h>
 #endif
 
+#include <QAbstractItemView>
 #include <QTime>
 #include <QTimer>
 #include <QThread>
diff --git a/src/script.cpp b/src/script.cpp
index 2327977..af8623e 100644
--- a/src/script.cpp
+++ b/src/script.cpp
@@ -10,6 +10,7 @@
 using namespace std;
 using namespace boost;
 
+#include "opensslcompat.h"
 #include "script.h"
 #include "keystore.h"
 #include "bignum.h"
@@ -867,17 +868,17 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co
                         break;
 
                     case OP_MUL:
-                        if (!BN_mul(&bn, &bn1, &bn2, pctx))
+                        if (!BN_mul(bn.getBN(), bn1.getBN(), bn2.getBN(), pctx))
                             return false;
                         break;
 
                     case OP_DIV:
-                        if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))
+                        if (!BN_div(bn.getBN(), NULL, bn1.getBN(), bn2.getBN(), pctx))
                             return false;
                         break;
 
                     case OP_MOD:
-                        if (!BN_mod(&bn, &bn1, &bn2, pctx))
+                        if (!BN_mod(bn.getBN(), bn1.getBN(), bn2.getBN(), pctx))
                             return false;
                         break;
 
